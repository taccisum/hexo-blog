### `豌豆全网数据脱敏（十亿级）`（2022.07 ~ 2022.08）

**背景**：由于搭建预发布环境需要，需在各部门的协同下将全网的生产数据同步至非生产环境。考虑到数据安全，需要在其中一个环节对全网数据进行脱敏（包括国内外手机号、身份证、地址、银行卡等等将近 1000+ 字段，数据量级达到几十亿），因此立专项处理
**整体流程**：脱敏整体架构设计 -> 脱敏算法设计 -> 脱敏命令行工具开发 -> 压测及时空性能优化 -> 发布正式版本 -> 交付并培训运维同学使用
**架构设计**：最终采用分散式架构，即 cli + 配置文件的方式，直连目标库进行数据脱敏。此架构具有诸多优点
  - **使用灵活性高**：受益于算法的无状态特性，在任何时间任何地点，只要有 cli + 写好的 json 文件即可执行（且随时可以中断，多次执行也可识别出增量数据），从管理上来说也便于拆解成子任务后交由不同的人员去并行执行（而不是一个巨大的、不可分割的任务）
  - **伸缩性佳**：有机器资源就能执行，单机性能不够时可以很方便地进行扩展，且可以选择距离数据库更近的机器执行，以降低网络开销
  - **数据安全性更可控**：我们只是提供工具，所有的配置文件、执行过程产生的数据完全由运维同学把控，可以更有效避免重要信息（如密钥）泄漏
  - **服务器成本低**：只有在执行脱敏时会占用服务器资源，平时就是占用一点硬盘空间
  - **存储成本极低**：由于采用了无状态的脱敏算法，没有任何需要持久化存储的中间状态（例如有状态算法为了避免数据重复，可能会存储脱敏前后的映射），存储成本几乎为零（除了一些必要的安全审计信息外）
  - **研发成本低**：采用 javascript 脚本语言编写，开发效率较高；采用命令行的方式也省去了开发 UI 的前端成本；且 js 作为前端主流语言，后续需要维护也不会有人员上的问题（随便一个前端都能搞定，这也是为什么最后选择了 js 而非 python 或其它语言的原因）
**技术难点**：
  - **无状态算法**：无状态要求算法执行过程不能存储任何中间状态，这给整个算法的设计带来许多麻烦，以手机号脱敏算法为例，需要满足以下性质
    - **幂等性**：由于不同的表字段可能存储同样的号码，这要求同一个号码多次脱敏应该是同样的结果
    - **唯一性**：对于原先不重复的号码集，脱敏后也应该没有重复数据
    - **不可逆性**：脱敏结果应该是不可逆的（也就是说即使算法泄漏，也无法通过这个结果逆向出原来的号码
    - **真实性**：应测试同学要求，我们不能修改原号码格式（这很可能会导致 ui 验证、参数校验等场景出现问题）
  - **应对暴力破解**：由于脱敏方案相关文档及源码的存在，算法总是有泄漏的可能。问题在于当算法泄漏后，是否有可能通过暴力运算的方式逆向出原始数据呢？因此我们需要对破解成本进行估计，并将其提升至我们能接受的安全范围内（**最终优化的破解成本为单机 1c1g 需要超过 21w 天的运算时间**）
  - **处理增量数据**：根据业务需要，可能每隔半年至一年不等就需要重新从生产环境同步一次增量的数据（全量成本太高），因此需要为每类数据嵌入合适的脱敏特征，以便我们能快速识别出其是否增量数据（同时这对工具的容错性也有巨大的意义）
  - **脱敏工具性能优化**：由于数据量巨大（达数十亿），对时空性能的优化就有了重大的意义。优化的核心是采用响应式编程，充分复用多核资源并行处理，最终的优化结果为 **4c8g 的机器上单次任务处理千万数据（读取、脱敏、重新写入）仅需 7min**；时间和空间与被处理数据量成线性关系（即复杂度为 O(n)），单次脱敏任务最高处理 1500w 处理。这个性能已经完全可以满足运维同学的使用要求，因此没有再做进一步的优化（理论上是可以的）
**技术选型**：Node.JS（js 缩主环境） + commander.js（命令行解析） + workerpool.js（多进程） + pkg.js（跨平台二进制打包）+ chalk + inquirer + mysql + ora + ...